{
  "name": "Yasudo",
  "tagline": "yet another sudo command helper",
  "body": "# yasudo - yet another sudo helper for node\r\n\r\nAn helper to run an `sudo` command with node.\r\n\r\n# Install\r\n\r\n```sh\r\nnpm i @mh-cbon/yasudo --save\r\n```\r\n\r\n# Usage\r\n\r\n```js\r\n// same as sudo sh -c 'ls -al'\r\n// it will ask for your password\r\nvar child = require('@mh-cbon/yasudo')('ls', ['-al']);\r\nchild.stdout.pipe(process.stdout);\r\nchild.stderr.pipe(process.stderr);\r\n\r\n// in depth options\r\nrequire('@mh-cbon/yasudo')('ls', ['-al'], {\r\n  password: 'your sudo password, to automatically answer the challenge',\r\n  sudo: {\r\n    // to configure behavior of sudo, see man sudo\r\n    k: true,  // When used without a command, invalidates the user's cached credentials.\r\n    E: true,  // Indicates to the security policy that the user wishes to preserve their existing envi‚Äê\r\n              // -ronment variables.\r\n    i: true,  // Run the shell specified by the target user's password database entry as a login shell.\r\n              // This means that login-specific resource files such as .profile or .login\r\n    K: true,  // Similar to the -k option, except that it removes the user's cached credentials entirely\r\n              // and may not be used in conjunction with a command or other option.\r\n    P: true,  // Preserve the invoking user's group vector unaltered.\r\n    C: 4,     // Close all file descriptors greater than or equal to num before executing a command.\r\n    g: \"the group\", // Run the command with the primary group set to group\r\n    u: \"the user\", // Run the command as a user other than the default target user (usually root).\r\n    r: \"the role\", // Run the command with an SELinux security context that includes the specified role.\r\n    t: \"the type\", // Run the command with an SELinux security context that includes the specified type.\r\n  }\r\n})\r\n\r\n// if one defines an ENV variable with its password,\r\n// then it is possible to run commands automatically\r\nvar child = require('@mh-cbon/yasudo', {password: process.env['pwd']})('ls', ['-al']);\r\nchild.stdout.pipe(process.stdout);\r\nchild.stderr.pipe(process.stderr);\r\n\r\n// last note, it exposes new events : success / faiure\r\nrequire('@mh-cbon/yasudo')('ls', ['-al'])\r\n.on('success', function () {\r\n  console.log('good to go !')\r\n})\r\n.on('failure', function () {\r\n  console.log('nop the challenge failed too many times')\r\n})\r\n.on('challenged', function (succeed) {\r\n  console.log('Challenge is now complete. succeeded ? %s', succeed)\r\n})\r\n```\r\n\r\n# Internals\r\n\r\nIt works by echoing a `token` on `stdout` and later detects it to determine that `sudo` succeeded.\r\n\r\nfor sure,\r\n- it does not rely on the output content of `sudo` to detect success/failure\r\n- it does not clutter your output with my token\r\n- it respects `stdio` settings such as `inherit` and `ignore`\r\n- it works seamlessly, even for `stdin`, see [this example](https://github.com/mh-cbon/yasudo/blob/master/examples/stdin.js)\r\n\r\n# Todo\r\n\r\n- support `ipc` `stdio` setting\r\n\r\n# Tests\r\n\r\nTo run the tests you shall use a command like this :\r\n\r\n```sh\r\npwd=<your sudo password> mocha tests/\r\n```\r\n\r\n# Read more\r\n\r\n- http://stackoverflow.com/questions/1507816/with-bash-how-can-i-pipe-standard-error-into-another-process\r\n- https://github.com/calmh/node-sudo\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}